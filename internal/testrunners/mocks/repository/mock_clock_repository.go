// Code generated by MockGen. DO NOT EDIT.
// Source: /home/kamil5b/REDIKRU/lumen-pg/internal/interfaces/repository/clock_repository.go

// Package mockrepository is a generated GoMock package.
package mockrepository

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockClockRepository is a mock of ClockRepository interface.
type MockClockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockClockRepositoryMockRecorder
}

// MockClockRepositoryMockRecorder is the mock recorder for MockClockRepository.
type MockClockRepositoryMockRecorder struct {
	mock *MockClockRepository
}

// NewMockClockRepository creates a new mock instance.
func NewMockClockRepository(ctrl *gomock.Controller) *MockClockRepository {
	mock := &MockClockRepository{ctrl: ctrl}
	mock.recorder = &MockClockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClockRepository) EXPECT() *MockClockRepositoryMockRecorder {
	return m.recorder
}

// AddSeconds mocks base method.
func (m *MockClockRepository) AddSeconds(ctx context.Context, seconds int64) int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddSeconds", ctx, seconds)
	ret0, _ := ret[0].(int64)
	return ret0
}

// AddSeconds indicates an expected call of AddSeconds.
func (mr *MockClockRepositoryMockRecorder) AddSeconds(ctx, seconds interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddSeconds", reflect.TypeOf((*MockClockRepository)(nil).AddSeconds), ctx, seconds)
}

// IsExpired mocks base method.
func (m *MockClockRepository) IsExpired(ctx context.Context, expirationTime int64) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsExpired", ctx, expirationTime)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsExpired indicates an expected call of IsExpired.
func (mr *MockClockRepositoryMockRecorder) IsExpired(ctx, expirationTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsExpired", reflect.TypeOf((*MockClockRepository)(nil).IsExpired), ctx, expirationTime)
}

// Now mocks base method.
func (m *MockClockRepository) Now(ctx context.Context) int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Now", ctx)
	ret0, _ := ret[0].(int64)
	return ret0
}

// Now indicates an expected call of Now.
func (mr *MockClockRepositoryMockRecorder) Now(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Now", reflect.TypeOf((*MockClockRepository)(nil).Now), ctx)
}

// NowNano mocks base method.
func (m *MockClockRepository) NowNano(ctx context.Context) int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NowNano", ctx)
	ret0, _ := ret[0].(int64)
	return ret0
}

// NowNano indicates an expected call of NowNano.
func (mr *MockClockRepositoryMockRecorder) NowNano(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NowNano", reflect.TypeOf((*MockClockRepository)(nil).NowNano), ctx)
}

// TimeUntilExpiration mocks base method.
func (m *MockClockRepository) TimeUntilExpiration(ctx context.Context, expirationTime int64) int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TimeUntilExpiration", ctx, expirationTime)
	ret0, _ := ret[0].(int64)
	return ret0
}

// TimeUntilExpiration indicates an expected call of TimeUntilExpiration.
func (mr *MockClockRepositoryMockRecorder) TimeUntilExpiration(ctx, expirationTime interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TimeUntilExpiration", reflect.TypeOf((*MockClockRepository)(nil).TimeUntilExpiration), ctx, expirationTime)
}
