// Code generated by MockGen. DO NOT EDIT.
// Source: /home/kamil5b/REDIKRU/lumen-pg/internal/interfaces/usecase/query_usecase.go

// Package mockusecase is a generated GoMock package.
package mockusecase

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	domain "github.com/kamil5b/lumen-pg/internal/domain"
)

// MockQueryUseCase is a mock of QueryUseCase interface.
type MockQueryUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockQueryUseCaseMockRecorder
}

// MockQueryUseCaseMockRecorder is the mock recorder for MockQueryUseCase.
type MockQueryUseCaseMockRecorder struct {
	mock *MockQueryUseCase
}

// NewMockQueryUseCase creates a new mock instance.
func NewMockQueryUseCase(ctrl *gomock.Controller) *MockQueryUseCase {
	mock := &MockQueryUseCase{ctrl: ctrl}
	mock.recorder = &MockQueryUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueryUseCase) EXPECT() *MockQueryUseCaseMockRecorder {
	return m.recorder
}

// ExecuteMultipleQueries mocks base method.
func (m *MockQueryUseCase) ExecuteMultipleQueries(ctx context.Context, username, queries string) ([]domain.QueryResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteMultipleQueries", ctx, username, queries)
	ret0, _ := ret[0].([]domain.QueryResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteMultipleQueries indicates an expected call of ExecuteMultipleQueries.
func (mr *MockQueryUseCaseMockRecorder) ExecuteMultipleQueries(ctx, username, queries interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteMultipleQueries", reflect.TypeOf((*MockQueryUseCase)(nil).ExecuteMultipleQueries), ctx, username, queries)
}

// ExecuteQuery mocks base method.
func (m *MockQueryUseCase) ExecuteQuery(ctx context.Context, username, query string, offset, limit int) (*domain.QueryResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteQuery", ctx, username, query, offset, limit)
	ret0, _ := ret[0].(*domain.QueryResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteQuery indicates an expected call of ExecuteQuery.
func (mr *MockQueryUseCaseMockRecorder) ExecuteQuery(ctx, username, query, offset, limit interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteQuery", reflect.TypeOf((*MockQueryUseCase)(nil).ExecuteQuery), ctx, username, query, offset, limit)
}

// ExecuteQueryWithPagination mocks base method.
func (m *MockQueryUseCase) ExecuteQueryWithPagination(ctx context.Context, username string, params domain.QueryParams) (*domain.QueryResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecuteQueryWithPagination", ctx, username, params)
	ret0, _ := ret[0].(*domain.QueryResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteQueryWithPagination indicates an expected call of ExecuteQueryWithPagination.
func (mr *MockQueryUseCaseMockRecorder) ExecuteQueryWithPagination(ctx, username, params interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteQueryWithPagination", reflect.TypeOf((*MockQueryUseCase)(nil).ExecuteQueryWithPagination), ctx, username, params)
}

// GetQueryAffectedRowCount mocks base method.
func (m *MockQueryUseCase) GetQueryAffectedRowCount(ctx context.Context, result *domain.QueryResult) int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetQueryAffectedRowCount", ctx, result)
	ret0, _ := ret[0].(int64)
	return ret0
}

// GetQueryAffectedRowCount indicates an expected call of GetQueryAffectedRowCount.
func (mr *MockQueryUseCaseMockRecorder) GetQueryAffectedRowCount(ctx, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetQueryAffectedRowCount", reflect.TypeOf((*MockQueryUseCase)(nil).GetQueryAffectedRowCount), ctx, result)
}

// IsDDLQuery mocks base method.
func (m *MockQueryUseCase) IsDDLQuery(ctx context.Context, query string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDDLQuery", ctx, query)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDDLQuery indicates an expected call of IsDDLQuery.
func (mr *MockQueryUseCaseMockRecorder) IsDDLQuery(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDDLQuery", reflect.TypeOf((*MockQueryUseCase)(nil).IsDDLQuery), ctx, query)
}

// IsDMLQuery mocks base method.
func (m *MockQueryUseCase) IsDMLQuery(ctx context.Context, query string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDMLQuery", ctx, query)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDMLQuery indicates an expected call of IsDMLQuery.
func (mr *MockQueryUseCaseMockRecorder) IsDMLQuery(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDMLQuery", reflect.TypeOf((*MockQueryUseCase)(nil).IsDMLQuery), ctx, query)
}

// IsSelectQuery mocks base method.
func (m *MockQueryUseCase) IsSelectQuery(ctx context.Context, query string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsSelectQuery", ctx, query)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsSelectQuery indicates an expected call of IsSelectQuery.
func (mr *MockQueryUseCaseMockRecorder) IsSelectQuery(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSelectQuery", reflect.TypeOf((*MockQueryUseCase)(nil).IsSelectQuery), ctx, query)
}

// SplitQueries mocks base method.
func (m *MockQueryUseCase) SplitQueries(ctx context.Context, queries string) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SplitQueries", ctx, queries)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SplitQueries indicates an expected call of SplitQueries.
func (mr *MockQueryUseCaseMockRecorder) SplitQueries(ctx, queries interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SplitQueries", reflect.TypeOf((*MockQueryUseCase)(nil).SplitQueries), ctx, queries)
}

// ValidateQuery mocks base method.
func (m *MockQueryUseCase) ValidateQuery(ctx context.Context, query string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ValidateQuery", ctx, query)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ValidateQuery indicates an expected call of ValidateQuery.
func (mr *MockQueryUseCaseMockRecorder) ValidateQuery(ctx, query interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ValidateQuery", reflect.TypeOf((*MockQueryUseCase)(nil).ValidateQuery), ctx, query)
}
